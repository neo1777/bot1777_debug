// Mocks generated by Mockito 5.4.6 from annotations
// in neotradingbotback1777/test/integration/system_stability_integration_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i3;

import 'package:fpdart/fpdart.dart' as _i8;
import 'package:get_it/get_it.dart' as _i23;
import 'package:mockito/mockito.dart' as _i1;
import 'package:mockito/src/dummies.dart' as _i10;
import 'package:neotradingbotback1777/application/managers/atomic_state_manager.dart'
    as _i7;
import 'package:neotradingbotback1777/application/managers/trading_loop_manager.dart'
    as _i4;
import 'package:neotradingbotback1777/application/monitoring/isolate_health_monitor.dart'
    as _i5;
import 'package:neotradingbotback1777/domain/entities/account_info.dart'
    as _i15;
import 'package:neotradingbotback1777/domain/entities/app_settings.dart' as _i6;
import 'package:neotradingbotback1777/domain/entities/app_strategy_state.dart'
    as _i2;
import 'package:neotradingbotback1777/domain/entities/exchange_info.dart'
    as _i21;
import 'package:neotradingbotback1777/domain/entities/kline.dart' as _i22;
import 'package:neotradingbotback1777/domain/entities/order_response.dart'
    as _i20;
import 'package:neotradingbotback1777/domain/entities/price.dart' as _i13;
import 'package:neotradingbotback1777/domain/entities/symbol_info.dart' as _i17;
import 'package:neotradingbotback1777/domain/entities/ticker_info.dart' as _i12;
import 'package:neotradingbotback1777/domain/failures/failures.dart' as _i9;
import 'package:neotradingbotback1777/domain/repositories/account_repository.dart'
    as _i14;
import 'package:neotradingbotback1777/domain/repositories/i_symbol_info_repository.dart'
    as _i16;
import 'package:neotradingbotback1777/domain/repositories/price_repository.dart'
    as _i11;
import 'package:neotradingbotback1777/domain/services/i_trading_api_service.dart'
    as _i19;
import 'package:neotradingbotback1777/domain/services/trade_evaluator_service.dart'
    as _i18;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: must_be_immutable
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class
// ignore_for_file: invalid_use_of_internal_member

class _FakeDuration_0 extends _i1.SmartFake implements Duration {
  _FakeDuration_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeAppStrategyState_1 extends _i1.SmartFake
    implements _i2.AppStrategyState {
  _FakeAppStrategyState_1(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeFuture_2<T1> extends _i1.SmartFake implements _i3.Future<T1> {
  _FakeFuture_2(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [TradingLoopManager].
///
/// See the documentation for Mockito's code generation for more information.
class MockTradingLoopManager extends _i1.Mock
    implements _i4.TradingLoopManager {
  MockTradingLoopManager() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Stream<Map<String, _i5.IsolateHealthInfo>> get healthStream =>
      (super.noSuchMethod(
        Invocation.getter(#healthStream),
        returnValue: _i3.Stream<Map<String, _i5.IsolateHealthInfo>>.empty(),
      ) as _i3.Stream<Map<String, _i5.IsolateHealthInfo>>);

  @override
  _i3.Future<void> stopAndRemoveLoop(String? symbol) => (super.noSuchMethod(
        Invocation.method(
          #stopAndRemoveLoop,
          [symbol],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  void resetCircuitBreakersForSymbol(String? symbol) => super.noSuchMethod(
        Invocation.method(
          #resetCircuitBreakersForSymbol,
          [symbol],
        ),
        returnValueForMissingStub: null,
      );

  @override
  Map<String, _i5.IsolateHealthInfo> getHealthInfo() => (super.noSuchMethod(
        Invocation.method(
          #getHealthInfo,
          [],
        ),
        returnValue: <String, _i5.IsolateHealthInfo>{},
      ) as Map<String, _i5.IsolateHealthInfo>);

  @override
  _i5.IsolateHealthInfo? getHealthInfoForSymbol(String? symbol) =>
      (super.noSuchMethod(Invocation.method(
        #getHealthInfoForSymbol,
        [symbol],
      )) as _i5.IsolateHealthInfo?);

  @override
  Map<String, dynamic> getHealthReport() => (super.noSuchMethod(
        Invocation.method(
          #getHealthReport,
          [],
        ),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);

  @override
  _i3.Future<bool> startAtomicLoopForSymbol(
    String? symbol,
    _i6.AppSettings? settings,
    _i2.AppStrategyState? initialState,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #startAtomicLoopForSymbol,
          [
            symbol,
            settings,
            initialState,
          ],
        ),
        returnValue: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);

  @override
  _i3.Future<void> startLoopForSymbol(
    String? symbol,
    _i6.AppSettings? settings,
    _i2.AppStrategyState? initialState,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #startLoopForSymbol,
          [
            symbol,
            settings,
            initialState,
          ],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  void dispose() => super.noSuchMethod(
        Invocation.method(
          #dispose,
          [],
        ),
        returnValueForMissingStub: null,
      );
}

/// A class which mocks [AtomicStateManager].
///
/// See the documentation for Mockito's code generation for more information.
class MockAtomicStateManager extends _i1.Mock
    implements _i7.AtomicStateManager {
  MockAtomicStateManager() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get persistChanges => (super.noSuchMethod(
        Invocation.getter(#persistChanges),
        returnValue: false,
      ) as bool);

  @override
  Duration get cacheTimeout => (super.noSuchMethod(
        Invocation.getter(#cacheTimeout),
        returnValue: _FakeDuration_0(
          this,
          Invocation.getter(#cacheTimeout),
        ),
      ) as Duration);

  @override
  int get maxCacheEntries => (super.noSuchMethod(
        Invocation.getter(#maxCacheEntries),
        returnValue: 0,
      ) as int);

  @override
  Duration get maxCacheAge => (super.noSuchMethod(
        Invocation.getter(#maxCacheAge),
        returnValue: _FakeDuration_0(
          this,
          Invocation.getter(#maxCacheAge),
        ),
      ) as Duration);

  @override
  _i3.Future<
      _i8.Either<_i9.Failure, _i2.AppStrategyState>> executeAtomicOperation(
    String? symbol,
    _i3.Future<_i8.Either<_i9.Failure, _i2.AppStrategyState>> Function(
            _i2.AppStrategyState)?
        operation,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #executeAtomicOperation,
          [
            symbol,
            operation,
          ],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i2.AppStrategyState>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i2.AppStrategyState>>(
          this,
          Invocation.method(
            #executeAtomicOperation,
            [
              symbol,
              operation,
            ],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i2.AppStrategyState>>);

  @override
  void invalidateCache() => super.noSuchMethod(
        Invocation.method(
          #invalidateCache,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void invalidateCacheForSymbol(String? symbol) => super.noSuchMethod(
        Invocation.method(
          #invalidateCacheForSymbol,
          [symbol],
        ),
        returnValueForMissingStub: null,
      );

  @override
  Map<String, dynamic> getCacheStats() => (super.noSuchMethod(
        Invocation.method(
          #getCacheStats,
          [],
        ),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);

  @override
  void forceCacheCleanup() => super.noSuchMethod(
        Invocation.method(
          #forceCacheCleanup,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void startPeriodicCleanup(
          {Duration? interval = const Duration(minutes: 5)}) =>
      super.noSuchMethod(
        Invocation.method(
          #startPeriodicCleanup,
          [],
          {#interval: interval},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void stopPeriodicCleanup() => super.noSuchMethod(
        Invocation.method(
          #stopPeriodicCleanup,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  _i3.Future<void> performHeartbeat() => (super.noSuchMethod(
        Invocation.method(
          #performHeartbeat,
          [],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i2.AppStrategyState>> getState(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getState,
          [symbol],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i2.AppStrategyState>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i2.AppStrategyState>>(
          this,
          Invocation.method(
            #getState,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i2.AppStrategyState>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> forceUpdateState(
          _i2.AppStrategyState? state) =>
      (super.noSuchMethod(
        Invocation.method(
          #forceUpdateState,
          [state],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #forceUpdateState,
            [state],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  void seedState(_i2.AppStrategyState? state) => super.noSuchMethod(
        Invocation.method(
          #seedState,
          [state],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void dispose() => super.noSuchMethod(
        Invocation.method(
          #dispose,
          [],
        ),
        returnValueForMissingStub: null,
      );
}

/// A class which mocks [PriceRepository].
///
/// See the documentation for Mockito's code generation for more information.
class MockPriceRepository extends _i1.Mock implements _i11.PriceRepository {
  MockPriceRepository() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> saveCurrentPrice(
    String? symbol,
    double? price,
  ) =>
      (super.noSuchMethod(
        Invocation.method(
          #saveCurrentPrice,
          [
            symbol,
            price,
          ],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #saveCurrentPrice,
            [
              symbol,
              price,
            ],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, double?>> getCurrentPrice(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getCurrentPrice,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, double?>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, double?>>(
          this,
          Invocation.method(
            #getCurrentPrice,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, double?>>);

  @override
  _i3.Stream<_i8.Either<_i9.Failure, double>> subscribeToPriceStream(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #subscribeToPriceStream,
          [symbol],
        ),
        returnValue: _i3.Stream<_i8.Either<_i9.Failure, double>>.empty(),
      ) as _i3.Stream<_i8.Either<_i9.Failure, double>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, DateTime?>> getLastPriceUpdate(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getLastPriceUpdate,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, DateTime?>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, DateTime?>>(
          this,
          Invocation.method(
            #getLastPriceUpdate,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, DateTime?>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> clearPriceCache(String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #clearPriceCache,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #clearPriceCache,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> clearAllPrices() =>
      (super.noSuchMethod(
        Invocation.method(
          #clearAllPrices,
          [],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #clearAllPrices,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, Map<String, double>>> getPrices(
          List<String>? symbols) =>
      (super.noSuchMethod(
        Invocation.method(
          #getPrices,
          [symbols],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, Map<String, double>>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, Map<String, double>>>(
          this,
          Invocation.method(
            #getPrices,
            [symbols],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, Map<String, double>>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i12.TickerInfo>> getTickerInfo(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getTickerInfo,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, _i12.TickerInfo>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, _i12.TickerInfo>>(
          this,
          Invocation.method(
            #getTickerInfo,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i12.TickerInfo>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i8.Unit>> updatePrice(
          _i13.Price? price) =>
      (super.noSuchMethod(
        Invocation.method(
          #updatePrice,
          [price],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, _i8.Unit>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, _i8.Unit>>(
          this,
          Invocation.method(
            #updatePrice,
            [price],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i8.Unit>>);
}

/// A class which mocks [AccountRepository].
///
/// See the documentation for Mockito's code generation for more information.
class MockAccountRepository extends _i1.Mock implements _i14.AccountRepository {
  MockAccountRepository() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> saveAccountInfo(
          _i15.AccountInfo? accountInfo) =>
      (super.noSuchMethod(
        Invocation.method(
          #saveAccountInfo,
          [accountInfo],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #saveAccountInfo,
            [accountInfo],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo?>> getAccountInfo() =>
      (super.noSuchMethod(
        Invocation.method(
          #getAccountInfo,
          [],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo?>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i15.AccountInfo?>>(
          this,
          Invocation.method(
            #getAccountInfo,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo?>>);

  @override
  _i3.Stream<_i8.Either<_i9.Failure, _i15.AccountInfo>>
      subscribeToAccountInfoStream() => (super.noSuchMethod(
            Invocation.method(
              #subscribeToAccountInfoStream,
              [],
            ),
            returnValue:
                _i3.Stream<_i8.Either<_i9.Failure, _i15.AccountInfo>>.empty(),
          ) as _i3.Stream<_i8.Either<_i9.Failure, _i15.AccountInfo>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> clearAccountInfo() =>
      (super.noSuchMethod(
        Invocation.method(
          #clearAccountInfo,
          [],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #clearAccountInfo,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo>> refreshAccountInfo() =>
      (super.noSuchMethod(
        Invocation.method(
          #refreshAccountInfo,
          [],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i15.AccountInfo>>(
          this,
          Invocation.method(
            #refreshAccountInfo,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo>>);
}

/// A class which mocks [ISymbolInfoRepository].
///
/// See the documentation for Mockito's code generation for more information.
class MockISymbolInfoRepository extends _i1.Mock
    implements _i16.ISymbolInfoRepository {
  MockISymbolInfoRepository() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i17.SymbolInfo>> getSymbolInfo(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getSymbolInfo,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, _i17.SymbolInfo>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, _i17.SymbolInfo>>(
          this,
          Invocation.method(
            #getSymbolInfo,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i17.SymbolInfo>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i8.Unit>> refreshSymbolInfoCache() =>
      (super.noSuchMethod(
        Invocation.method(
          #refreshSymbolInfoCache,
          [],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, _i8.Unit>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, _i8.Unit>>(
          this,
          Invocation.method(
            #refreshSymbolInfoCache,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i8.Unit>>);
}

/// A class which mocks [TradeEvaluatorService].
///
/// See the documentation for Mockito's code generation for more information.
class MockTradeEvaluatorService extends _i1.Mock
    implements _i18.TradeEvaluatorService {
  MockTradeEvaluatorService() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool shouldBuyInitial({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    required bool? warmupSatisfied,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #shouldBuyInitial,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
            #warmupSatisfied: warmupSatisfied,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  bool shouldBuyNonInitial({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #shouldBuyNonInitial,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  bool shouldBuyGuarded({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    bool? allowInitialBuy = false,
    double? availableBalance,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #shouldBuyGuarded,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
            #allowInitialBuy: allowInitialBuy,
            #availableBalance: availableBalance,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  bool shouldSell({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    bool? inDustCooldown = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #shouldSell,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
            #inDustCooldown: inDustCooldown,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  _i3.Future<bool> shouldSellWithFees({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    bool? inDustCooldown = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #shouldSellWithFees,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
            #inDustCooldown: inDustCooldown,
          },
        ),
        returnValue: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);

  @override
  bool shouldDcaBuy({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    bool? compareAgainstAverage = false,
    double? availableBalance,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #shouldDcaBuy,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
            #compareAgainstAverage: compareAgainstAverage,
            #availableBalance: availableBalance,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  _i18.TradingDecision? evaluateTradingDecisions({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    bool? allowInitialBuy = false,
  }) =>
      (super.noSuchMethod(Invocation.method(
        #evaluateTradingDecisions,
        [],
        {
          #currentPrice: currentPrice,
          #state: state,
          #settings: settings,
          #allowInitialBuy: allowInitialBuy,
        },
      )) as _i18.TradingDecision?);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i18.TradingDecision?>>
      evaluateTradingDecisionsWithFees({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
    bool? allowInitialBuy = false,
  }) =>
          (super.noSuchMethod(
            Invocation.method(
              #evaluateTradingDecisionsWithFees,
              [],
              {
                #currentPrice: currentPrice,
                #state: state,
                #settings: settings,
                #allowInitialBuy: allowInitialBuy,
              },
            ),
            returnValue: _i3
                .Future<_i8.Either<_i9.Failure, _i18.TradingDecision?>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i18.TradingDecision?>>(
              this,
              Invocation.method(
                #evaluateTradingDecisionsWithFees,
                [],
                {
                  #currentPrice: currentPrice,
                  #state: state,
                  #settings: settings,
                  #allowInitialBuy: allowInitialBuy,
                },
              ),
            )),
          ) as _i3.Future<_i8.Either<_i9.Failure, _i18.TradingDecision?>>);

  @override
  _i2.AppStrategyState evaluateVolatilityAndUpdateState({
    required double? currentPrice,
    required _i2.AppStrategyState? state,
    required _i6.AppSettings? settings,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #evaluateVolatilityAndUpdateState,
          [],
          {
            #currentPrice: currentPrice,
            #state: state,
            #settings: settings,
          },
        ),
        returnValue: _FakeAppStrategyState_1(
          this,
          Invocation.method(
            #evaluateVolatilityAndUpdateState,
            [],
            {
              #currentPrice: currentPrice,
              #state: state,
              #settings: settings,
            },
          ),
        ),
      ) as _i2.AppStrategyState);
}

/// A class which mocks [ITradingApiService].
///
/// See the documentation for Mockito's code generation for more information.
class MockITradingApiService extends _i1.Mock
    implements _i19.ITradingApiService {
  MockITradingApiService() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get isTestMode => (super.noSuchMethod(
        Invocation.getter(#isTestMode),
        returnValue: false,
      ) as bool);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i20.OrderResponse>> createOrder({
    required String? symbol,
    required double? quantity,
    required String? side,
    String? clientOrderId,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #createOrder,
          [],
          {
            #symbol: symbol,
            #quantity: quantity,
            #side: side,
            #clientOrderId: clientOrderId,
          },
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i20.OrderResponse>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i20.OrderResponse>>(
          this,
          Invocation.method(
            #createOrder,
            [],
            {
              #symbol: symbol,
              #quantity: quantity,
              #side: side,
              #clientOrderId: clientOrderId,
            },
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i20.OrderResponse>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo>> getAccountInfo() =>
      (super.noSuchMethod(
        Invocation.method(
          #getAccountInfo,
          [],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i15.AccountInfo>>(
          this,
          Invocation.method(
            #getAccountInfo,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i15.AccountInfo>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, List<Map<String, dynamic>>>> getOpenOrders(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getOpenOrders,
          [symbol],
        ),
        returnValue: _i3
            .Future<_i8.Either<_i9.Failure, List<Map<String, dynamic>>>>.value(
            _i10.dummyValue<
                _i8.Either<_i9.Failure, List<Map<String, dynamic>>>>(
          this,
          Invocation.method(
            #getOpenOrders,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, List<Map<String, dynamic>>>>);

  @override
  _i3.Stream<_i8.Either<_i9.Failure, double>> subscribeToPriceStream(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #subscribeToPriceStream,
          [symbol],
        ),
        returnValue: _i3.Stream<_i8.Either<_i9.Failure, double>>.empty(),
      ) as _i3.Stream<_i8.Either<_i9.Failure, double>>);

  @override
  _i3.Stream<_i8.Either<_i9.Failure, _i15.AccountInfo>>
      subscribeToAccountInfoStream() => (super.noSuchMethod(
            Invocation.method(
              #subscribeToAccountInfoStream,
              [],
            ),
            returnValue:
                _i3.Stream<_i8.Either<_i9.Failure, _i15.AccountInfo>>.empty(),
          ) as _i3.Stream<_i8.Either<_i9.Failure, _i15.AccountInfo>>);

  @override
  _i3.Future<void> initialize() => (super.noSuchMethod(
        Invocation.method(
          #initialize,
          [],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  void dispose() => super.noSuchMethod(
        Invocation.method(
          #dispose,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  Map<String, dynamic> getWebSocketStats() => (super.noSuchMethod(
        Invocation.method(
          #getWebSocketStats,
          [],
        ),
        returnValue: <String, dynamic>{},
      ) as Map<String, dynamic>);

  @override
  _i3.Future<void> forceWebSocketReconnect() => (super.noSuchMethod(
        Invocation.method(
          #forceWebSocketReconnect,
          [],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i12.TickerInfo>> getTickerInfo(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getTickerInfo,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, _i12.TickerInfo>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, _i12.TickerInfo>>(
          this,
          Invocation.method(
            #getTickerInfo,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i12.TickerInfo>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i13.Price>> getLatestPrice(
          String? symbol) =>
      (super.noSuchMethod(
        Invocation.method(
          #getLatestPrice,
          [symbol],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, _i13.Price>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, _i13.Price>>(
          this,
          Invocation.method(
            #getLatestPrice,
            [symbol],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i13.Price>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, _i21.ExchangeInfo>> getExchangeInfo() =>
      (super.noSuchMethod(
        Invocation.method(
          #getExchangeInfo,
          [],
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, _i21.ExchangeInfo>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, _i21.ExchangeInfo>>(
          this,
          Invocation.method(
            #getExchangeInfo,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, _i21.ExchangeInfo>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, List<Map<String, dynamic>>>>
      getAccountTradeFees() => (super.noSuchMethod(
            Invocation.method(
              #getAccountTradeFees,
              [],
            ),
            returnValue: _i3.Future<
                    _i8.Either<_i9.Failure, List<Map<String, dynamic>>>>.value(
                _i10.dummyValue<
                    _i8.Either<_i9.Failure, List<Map<String, dynamic>>>>(
              this,
              Invocation.method(
                #getAccountTradeFees,
                [],
              ),
            )),
          ) as _i3.Future<_i8.Either<_i9.Failure, List<Map<String, dynamic>>>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, List<String>>> getActiveSymbols() =>
      (super.noSuchMethod(
        Invocation.method(
          #getActiveSymbols,
          [],
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, List<String>>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, List<String>>>(
          this,
          Invocation.method(
            #getActiveSymbols,
            [],
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, List<String>>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> cancelOrder({
    required String? symbol,
    required int? orderId,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #cancelOrder,
          [],
          {
            #symbol: symbol,
            #orderId: orderId,
          },
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #cancelOrder,
            [],
            {
              #symbol: symbol,
              #orderId: orderId,
            },
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  _i3.Future<_i8.Either<_i9.Failure, void>> cancelAllOpenOrders(
          {required String? symbol}) =>
      (super.noSuchMethod(
        Invocation.method(
          #cancelAllOpenOrders,
          [],
          {#symbol: symbol},
        ),
        returnValue: _i3.Future<_i8.Either<_i9.Failure, void>>.value(
            _i10.dummyValue<_i8.Either<_i9.Failure, void>>(
          this,
          Invocation.method(
            #cancelAllOpenOrders,
            [],
            {#symbol: symbol},
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, void>>);

  @override
  void updateMode({required bool? isTestMode}) => super.noSuchMethod(
        Invocation.method(
          #updateMode,
          [],
          {#isTestMode: isTestMode},
        ),
        returnValueForMissingStub: null,
      );

  @override
  _i3.Future<_i8.Either<_i9.Failure, List<_i22.Kline>>> getKlines({
    required String? symbol,
    required String? interval,
    int? startTime,
    int? endTime,
    int? limit,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getKlines,
          [],
          {
            #symbol: symbol,
            #interval: interval,
            #startTime: startTime,
            #endTime: endTime,
            #limit: limit,
          },
        ),
        returnValue:
            _i3.Future<_i8.Either<_i9.Failure, List<_i22.Kline>>>.value(
                _i10.dummyValue<_i8.Either<_i9.Failure, List<_i22.Kline>>>(
          this,
          Invocation.method(
            #getKlines,
            [],
            {
              #symbol: symbol,
              #interval: interval,
              #startTime: startTime,
              #endTime: endTime,
              #limit: limit,
            },
          ),
        )),
      ) as _i3.Future<_i8.Either<_i9.Failure, List<_i22.Kline>>>);
}

/// A class which mocks [GetIt].
///
/// See the documentation for Mockito's code generation for more information.
class MockGetIt extends _i1.Mock implements _i23.GetIt {
  MockGetIt() {
    _i1.throwOnMissingStub(this);
  }

  @override
  bool get debugEventsEnabled => (super.noSuchMethod(
        Invocation.getter(#debugEventsEnabled),
        returnValue: false,
      ) as bool);

  @override
  bool get allowReassignment => (super.noSuchMethod(
        Invocation.getter(#allowReassignment),
        returnValue: false,
      ) as bool);

  @override
  bool get skipDoubleRegistration => (super.noSuchMethod(
        Invocation.getter(#skipDoubleRegistration),
        returnValue: false,
      ) as bool);

  @override
  bool get allowRegisterMultipleImplementationsOfoneType => (super.noSuchMethod(
        Invocation.getter(#allowRegisterMultipleImplementationsOfoneType),
        returnValue: false,
      ) as bool);

  @override
  set onScopeChanged(void Function(bool)? value) => super.noSuchMethod(
        Invocation.setter(
          #onScopeChanged,
          value,
        ),
        returnValueForMissingStub: null,
      );

  @override
  set debugEventsEnabled(bool? value) => super.noSuchMethod(
        Invocation.setter(
          #debugEventsEnabled,
          value,
        ),
        returnValueForMissingStub: null,
      );

  @override
  set allowReassignment(bool? value) => super.noSuchMethod(
        Invocation.setter(
          #allowReassignment,
          value,
        ),
        returnValueForMissingStub: null,
      );

  @override
  set skipDoubleRegistration(bool? value) => super.noSuchMethod(
        Invocation.setter(
          #skipDoubleRegistration,
          value,
        ),
        returnValueForMissingStub: null,
      );

  @override
  set allowRegisterMultipleImplementationsOfoneType(bool? value) =>
      super.noSuchMethod(
        Invocation.setter(
          #allowRegisterMultipleImplementationsOfoneType,
          value,
        ),
        returnValueForMissingStub: null,
      );

  @override
  void enableRegisteringMultipleInstancesOfOneType() => super.noSuchMethod(
        Invocation.method(
          #enableRegisteringMultipleInstancesOfOneType,
          [],
        ),
        returnValueForMissingStub: null,
      );

  @override
  T get<T extends Object>({
    dynamic param1,
    dynamic param2,
    String? instanceName,
    Type? type,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #get,
          [],
          {
            #param1: param1,
            #param2: param2,
            #instanceName: instanceName,
            #type: type,
          },
        ),
        returnValue: _i10.dummyValue<T>(
          this,
          Invocation.method(
            #get,
            [],
            {
              #param1: param1,
              #param2: param2,
              #instanceName: instanceName,
              #type: type,
            },
          ),
        ),
      ) as T);

  @override
  _i3.Future<T> getAsync<T extends Object>({
    String? instanceName,
    dynamic param1,
    dynamic param2,
    Type? type,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getAsync,
          [],
          {
            #instanceName: instanceName,
            #param1: param1,
            #param2: param2,
            #type: type,
          },
        ),
        returnValue: _i10.ifNotNull(
              _i10.dummyValueOrNull<T>(
                this,
                Invocation.method(
                  #getAsync,
                  [],
                  {
                    #instanceName: instanceName,
                    #param1: param1,
                    #param2: param2,
                    #type: type,
                  },
                ),
              ),
              (T v) => _i3.Future<T>.value(v),
            ) ??
            _FakeFuture_2<T>(
              this,
              Invocation.method(
                #getAsync,
                [],
                {
                  #instanceName: instanceName,
                  #param1: param1,
                  #param2: param2,
                  #type: type,
                },
              ),
            ),
      ) as _i3.Future<T>);

  @override
  Iterable<T> getAll<T extends Object>({
    dynamic param1,
    dynamic param2,
    bool? fromAllScopes = false,
    String? onlyInScope,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getAll,
          [],
          {
            #param1: param1,
            #param2: param2,
            #fromAllScopes: fromAllScopes,
            #onlyInScope: onlyInScope,
          },
        ),
        returnValue: <T>[],
      ) as Iterable<T>);

  @override
  _i3.Future<Iterable<T>> getAllAsync<T extends Object>({
    dynamic param1,
    dynamic param2,
    bool? fromAllScopes = false,
    String? onlyInScope,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #getAllAsync,
          [],
          {
            #param1: param1,
            #param2: param2,
            #fromAllScopes: fromAllScopes,
            #onlyInScope: onlyInScope,
          },
        ),
        returnValue: _i3.Future<Iterable<T>>.value(<T>[]),
      ) as _i3.Future<Iterable<T>>);

  @override
  List<T> findAll<T extends Object>({
    bool? includeSubtypes = true,
    bool? inAllScopes = false,
    String? onlyInScope,
    bool? includeMatchedByRegistrationType = true,
    bool? includeMatchedByInstance = true,
    bool? instantiateLazySingletons = false,
    bool? callFactories = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #findAll,
          [],
          {
            #includeSubtypes: includeSubtypes,
            #inAllScopes: inAllScopes,
            #onlyInScope: onlyInScope,
            #includeMatchedByRegistrationType: includeMatchedByRegistrationType,
            #includeMatchedByInstance: includeMatchedByInstance,
            #instantiateLazySingletons: instantiateLazySingletons,
            #callFactories: callFactories,
          },
        ),
        returnValue: <T>[],
      ) as List<T>);

  @override
  T call<T extends Object>({
    String? instanceName,
    dynamic param1,
    dynamic param2,
    Type? type,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #call,
          [],
          {
            #instanceName: instanceName,
            #param1: param1,
            #param2: param2,
            #type: type,
          },
        ),
        returnValue: _i10.dummyValue<T>(
          this,
          Invocation.method(
            #call,
            [],
            {
              #instanceName: instanceName,
              #param1: param1,
              #param2: param2,
              #type: type,
            },
          ),
        ),
      ) as T);

  @override
  void registerFactory<T extends Object>(
    _i23.FactoryFunc<T>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerFactory,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerCachedFactory<T extends Object>(
    _i23.FactoryFunc<T>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerCachedFactory,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerFactoryParam<T extends Object, P1, P2>(
    _i23.FactoryFuncParam<T, P1, P2>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerFactoryParam,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerCachedFactoryParam<T extends Object, P1, P2>(
    _i23.FactoryFuncParam<T, P1, P2>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerCachedFactoryParam,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerFactoryAsync<T extends Object>(
    _i23.FactoryFuncAsync<T>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerFactoryAsync,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerCachedFactoryAsync<T extends Object>(
    _i23.FactoryFuncAsync<T>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerCachedFactoryAsync,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerFactoryParamAsync<T extends Object, P1, P2>(
    _i23.FactoryFuncParamAsync<T, P1?, P2?>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerFactoryParamAsync,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerCachedFactoryParamAsync<T extends Object, P1, P2>(
    _i23.FactoryFuncParamAsync<T, P1?, P2?>? factoryFunc, {
    String? instanceName,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerCachedFactoryParamAsync,
          [factoryFunc],
          {#instanceName: instanceName},
        ),
        returnValueForMissingStub: null,
      );

  @override
  T registerSingleton<T extends Object>(
    T? instance, {
    String? instanceName,
    bool? signalsReady,
    _i23.DisposingFunc<T>? dispose,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #registerSingleton,
          [instance],
          {
            #instanceName: instanceName,
            #signalsReady: signalsReady,
            #dispose: dispose,
          },
        ),
        returnValue: _i10.dummyValue<T>(
          this,
          Invocation.method(
            #registerSingleton,
            [instance],
            {
              #instanceName: instanceName,
              #signalsReady: signalsReady,
              #dispose: dispose,
            },
          ),
        ),
      ) as T);

  @override
  T registerSingletonIfAbsent<T extends Object>(
    T Function()? factoryFunc, {
    String? instanceName,
    _i23.DisposingFunc<T>? dispose,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #registerSingletonIfAbsent,
          [factoryFunc],
          {
            #instanceName: instanceName,
            #dispose: dispose,
          },
        ),
        returnValue: _i10.dummyValue<T>(
          this,
          Invocation.method(
            #registerSingletonIfAbsent,
            [factoryFunc],
            {
              #instanceName: instanceName,
              #dispose: dispose,
            },
          ),
        ),
      ) as T);

  @override
  void releaseInstance(Object? instance) => super.noSuchMethod(
        Invocation.method(
          #releaseInstance,
          [instance],
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerSingletonWithDependencies<T extends Object>(
    _i23.FactoryFunc<T>? factoryFunc, {
    String? instanceName,
    required Iterable<Type>? dependsOn,
    bool? signalsReady,
    _i23.DisposingFunc<T>? dispose,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerSingletonWithDependencies,
          [factoryFunc],
          {
            #instanceName: instanceName,
            #dependsOn: dependsOn,
            #signalsReady: signalsReady,
            #dispose: dispose,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerSingletonAsync<T extends Object>(
    _i23.FactoryFuncAsync<T>? factoryFunc, {
    String? instanceName,
    Iterable<Type>? dependsOn,
    bool? signalsReady,
    _i23.DisposingFunc<T>? dispose,
    void Function(T)? onCreated,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerSingletonAsync,
          [factoryFunc],
          {
            #instanceName: instanceName,
            #dependsOn: dependsOn,
            #signalsReady: signalsReady,
            #dispose: dispose,
            #onCreated: onCreated,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerLazySingleton<T extends Object>(
    _i23.FactoryFunc<T>? factoryFunc, {
    String? instanceName,
    _i23.DisposingFunc<T>? dispose,
    void Function(T)? onCreated,
    bool? useWeakReference = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerLazySingleton,
          [factoryFunc],
          {
            #instanceName: instanceName,
            #dispose: dispose,
            #onCreated: onCreated,
            #useWeakReference: useWeakReference,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  void registerLazySingletonAsync<T extends Object>(
    _i23.FactoryFuncAsync<T>? factoryFunc, {
    String? instanceName,
    _i23.DisposingFunc<T>? dispose,
    void Function(T)? onCreated,
    bool? useWeakReference = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #registerLazySingletonAsync,
          [factoryFunc],
          {
            #instanceName: instanceName,
            #dispose: dispose,
            #onCreated: onCreated,
            #useWeakReference: useWeakReference,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  bool isRegistered<T extends Object>({
    Object? instance,
    String? instanceName,
    Type? type,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #isRegistered,
          [],
          {
            #instance: instance,
            #instanceName: instanceName,
            #type: type,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  void changeTypeInstanceName<T extends Object>({
    String? instanceName,
    required String? newInstanceName,
    T? instance,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #changeTypeInstanceName,
          [],
          {
            #instanceName: instanceName,
            #newInstanceName: newInstanceName,
            #instance: instance,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  _i3.Future<void> reset({bool? dispose = true}) => (super.noSuchMethod(
        Invocation.method(
          #reset,
          [],
          {#dispose: dispose},
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  _i3.Future<void> resetScope({bool? dispose = true}) => (super.noSuchMethod(
        Invocation.method(
          #resetScope,
          [],
          {#dispose: dispose},
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  void pushNewScope({
    void Function(_i23.GetIt)? init,
    String? scopeName,
    _i23.ScopeDisposeFunc? dispose,
    bool? isFinal,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #pushNewScope,
          [],
          {
            #init: init,
            #scopeName: scopeName,
            #dispose: dispose,
            #isFinal: isFinal,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  _i3.Future<void> pushNewScopeAsync({
    _i3.Future<void> Function(_i23.GetIt)? init,
    String? scopeName,
    _i23.ScopeDisposeFunc? dispose,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #pushNewScopeAsync,
          [],
          {
            #init: init,
            #scopeName: scopeName,
            #dispose: dispose,
          },
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  _i3.Future<void> popScope() => (super.noSuchMethod(
        Invocation.method(
          #popScope,
          [],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  _i3.Future<bool> popScopesTill(
    String? name, {
    bool? inclusive = true,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #popScopesTill,
          [name],
          {#inclusive: inclusive},
        ),
        returnValue: _i3.Future<bool>.value(false),
      ) as _i3.Future<bool>);

  @override
  _i3.Future<void> dropScope(String? scopeName) => (super.noSuchMethod(
        Invocation.method(
          #dropScope,
          [scopeName],
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  bool hasScope(String? scopeName) => (super.noSuchMethod(
        Invocation.method(
          #hasScope,
          [scopeName],
        ),
        returnValue: false,
      ) as bool);

  @override
  _i3.Future<void> resetLazySingletons({
    bool? dispose = true,
    bool? inAllScopes = false,
    String? onlyInScope,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #resetLazySingletons,
          [],
          {
            #dispose: dispose,
            #inAllScopes: inAllScopes,
            #onlyInScope: onlyInScope,
          },
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  bool checkLazySingletonInstanceExists<T extends Object>(
          {String? instanceName}) =>
      (super.noSuchMethod(
        Invocation.method(
          #checkLazySingletonInstanceExists,
          [],
          {#instanceName: instanceName},
        ),
        returnValue: false,
      ) as bool);

  @override
  _i3.FutureOr<dynamic> unregister<T extends Object>({
    Object? instance,
    String? instanceName,
    _i3.FutureOr<dynamic> Function(T)? disposingFunction,
    bool? ignoreReferenceCount = false,
  }) =>
      (super.noSuchMethod(Invocation.method(
        #unregister,
        [],
        {
          #instance: instance,
          #instanceName: instanceName,
          #disposingFunction: disposingFunction,
          #ignoreReferenceCount: ignoreReferenceCount,
        },
      )) as _i3.FutureOr<dynamic>);

  @override
  _i3.Future<void> allReady({
    Duration? timeout,
    bool? ignorePendingAsyncCreation = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #allReady,
          [],
          {
            #timeout: timeout,
            #ignorePendingAsyncCreation: ignorePendingAsyncCreation,
          },
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  _i3.Future<void> isReady<T extends Object>({
    Object? instance,
    String? instanceName,
    Duration? timeout,
    Object? callee,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #isReady,
          [],
          {
            #instance: instance,
            #instanceName: instanceName,
            #timeout: timeout,
            #callee: callee,
          },
        ),
        returnValue: _i3.Future<void>.value(),
        returnValueForMissingStub: _i3.Future<void>.value(),
      ) as _i3.Future<void>);

  @override
  bool isReadySync<T extends Object>({
    Object? instance,
    String? instanceName,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #isReadySync,
          [],
          {
            #instance: instance,
            #instanceName: instanceName,
          },
        ),
        returnValue: false,
      ) as bool);

  @override
  bool allReadySync([bool? ignorePendingAsyncCreation = false]) =>
      (super.noSuchMethod(
        Invocation.method(
          #allReadySync,
          [ignorePendingAsyncCreation],
        ),
        returnValue: false,
      ) as bool);

  @override
  void signalReady(Object? instance) => super.noSuchMethod(
        Invocation.method(
          #signalReady,
          [instance],
        ),
        returnValueForMissingStub: null,
      );
}
